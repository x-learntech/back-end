# Java 方法

## 方法的理解和语法格式

1. 解决某一件事的功能实现。方法，是一段代码块的封装，方法中的代码应围绕某一功能的实现来写，目标明确，逻辑清晰。
2. 格式：在 Java 中，声明一个方法的具体语法格式如下：

```java
修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2,．．．．．．){
  执行语句
  1.方法的调用
  2.变量的操作：声明 赋值  修改
  3.程序结构：选择结构 循环结构………
  return 返回值;
}
```

对于上面的语法格式中具体说明如下：

- 修饰符：方法的修饰符比较多，有对访问权限进行限定的，有静态修饰符 static，还有最终修饰符 final 等
- 返回值类型：用于限定方法返回值的数据类型
  - 有返回值：基本数据类型 类和接口
  - 没有返回值：void
- 参数类型：用于限定调用方法时传入参数的数据类型
- 参数名：是一个变量，用于接收调用方法时传入的数据
- return 关键字：用于结束方法以及返回方法指定类型的值
- 返回值：被 return 语句返回的值，该值会返回给调用者

需要特别注意的是，方法中的“参数类型 参数名 1，参数类型 参数名 2”被称作参数列表，它用于描述方法在被调用时需要接收的参数，如果方法不需要接收任何参数，则参数列表为空，即()内不写任何内容。方法的返回值必须为方法声明的返回值类型，如果方法中没有返回值，返回值类型要声明为 void，此时，方法中 return 语句可以省略。

## 方法的返回值

1. 返回值指的是：**根据实际的业务需求**，对某一功能用程序实现后，需要有一定的产出。

比如：榨一杯苹果汁，最后会产出一杯苹果汁。这个时候就有人会问：参数和返回值之间好像有着某种联系？

其实，这两者之间没有任何必然的联系。也就是说，一个方法，可以有参数，也可以没有参数，可以有参数，没有返回值，也可以有参数，也有返回值....

打个比方：盖房子需要木头，水泥，砖块。这些都是“盖房子”这个方法的参数，但是产出只有一个——房子。再打个比方，“种水稻”这个方法需要的参数有：种子，化肥，除草剂，产出的是大米。可天有不测风云，万一闹灾荒，可能颗粒无收，这个时候，没有产出。当然，我们希望的是每年风调雨顺，国泰民安。再比如，“学习”这个方法，需要的参数是：时间，精力，和思考。可最终是否学业有成，还得看个人在这个过程中是否用心了，有可能学业有成，知识高产出，也有可能中途放弃，或误入歪门邪道，最终没有产出。我们还是祝愿所有的学员能够学员有成！

2. 返回值类型定义在方法名的前面，分两种：

- 有返回值：基本数据类型，和引用数据类型（也就是类和接口）
- 无返回值：void

3. 返回值用关键字 return 表示。

## 方法的重载

同一个类中，**同名不同参数**的两个或以上的方法叫做方法的重载。有参构造和无参构造就是典型的方法重载。

判断是否是重载只看两个因素：

1. 方法名相同
2. 参数不同

其它的返回值 修饰符什么的都不用看。

## 封装(Encapsulation)

为什么要封装：为了隐蔽性和安全性。

所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。

1. 类有成员属性和方法两个部分组成，二者都可以供其它类去调用。方法作为一个功能的实现，被调用时不会产生什么问题，属性却不一样，它是属于类和对象的，容易被“非法篡改”--误操作。

例如：定义一个类 people，有姓名和财产，年龄等属性，默认值是：张三和 12000，36 岁.有 show 方法，输出姓名和财产和年龄。定义一个测试类，修改张三的 money 为-10000；
如果没有封装，发现属性值的赋值过程完全暴露在外，且不太好对年龄和性别加以限制。

2. 此案例可以看出类和对象的属性毫无隐蔽性可言，可以被随意修改，这样设计出的程序会有很大的安全性问题。
3. 为了解决这个问题，java 开发者提出了封装的思想。将类的成员属性的访问修饰符规定为私有（private），这样该属性在其它类就不能调用，更不可能被修改。这相当于闭关锁国政策，所以又面临一个问题：连成员属性的正常赋值也不可能在其它类中实现。因此设计者们再次提出了一个方案：成员属性可以间接地在其它类中被访问，也就是中间要设置一道检查和过滤的关卡，这道关卡就是 get 和 set 方法，它们被称为 getter 和 setter.

实现封装总结：

1. 属性访问修饰符定义为私有：private
2. 对外提供 get 和 set 方法。

### 访问修饰符

![2206-rSDx4a](https://cdn-static.learntech.cn/notes/20211005/2206-rSDx4a.png!min)

1. 类的访问修饰符：

- Public：对外公开
- 默认：所在包有效，包以外不能访问 --体现在构造方法上

2. 成员访问修饰符（成员属性和成员方法）

- Public：对外公开
- Protected：受保护的，同一个包的子类可以访问。
- 默认：同一个包中可以访问
- Private：只在当前类有效

3. static 和 this 关键字

- Static 修饰的，属于类范围的，this 代表当前对象。
- Static 修饰成员属性和方法和代码块

## 继承(Inheritance)

继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。

继承研究的是两个类之间的范围包含关系，用关键字 extends 表示。大范围作为父类，小范围作为子类。

使用：

1. 在多个子类中抽取出相同的属性和方法，形成父类的属性和方法。
2. 在各个子类中继承这些属性和方法的使用权限。

继承语法细节：

1. 子类构造方法会默认调用父类无参构造方法。即：在创建子类对象时，也会随即创建父类对象。
2. Java 中只支持单继承：一个子类只能有一个直接父类。
3. 任何一个类，都默认继承 Object 类，Object 类是所有类的父类。

**父类的静态方法和实例方法都可以继承**。

### 重写(Overriding)

子类方法和父类方法同名，子类方法会覆盖父类方法，称为重写（覆盖），前提，子类方法访问权限必须大于或等于父类方法的访问权限。

**静态方法可以被继承，不能被重写。**

重写的条件

> 参数列表必须完全与被重写方法的相同；
>
> 返回类型必须完全与被重写方法的返回类型相同；
>
> 访问级别的限制性一定不能比被重写方法的强；
>
> 访问级别的限制性可以比被重写方法的弱；
>
> 重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常更广泛的检查异常
>
> 重写的方法能够抛出更少或更有限的异常（也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明）
>
> 不能重写被标示为 final 的方法；
>
> 如果不能继承一个方法，则不能重写这个方法。

### 重载(Overloading)

简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。

重载的条件

> 被重载的方法必须改变参数列表；
>
> 被重载的方法可以改变返回类型；
>
> 被重载的方法可以改变访问修饰符；
>
> 被重载的方法可以声明新的或更广的检查异常；
>
> 方法能够在同一个类中或者在一个子类中被重载。

重写和重载(Overloading)的区别：

![2224-dn4Fcp](https://cdn-static.learntech.cn/notes/20211005/2224-dn4Fcp.png!min)

关于重载和重写，你应该知道以下几点：

> 1、重载是一个编译期概念、重写是一个运行期间概念。
>
> 2、重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。
>
> 3、重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法
>
> 4、因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，重载是编译时多态，即静态多态。但是，Java 中提到的多态，在不特别说明的情况下都指动态多态）

### this 和 super 的区别

this:

1. 本类成员方法中，访问本类成员变量，访问本类另一个成员方法
2. 本类构造方法中，访问本类另一个构造方法

Super:

1. 在子类成员方法中，访问父类成员变量和成员方法
2. 在子类构造方法中，访问父类构造方法

本类的成员变量和局部变量重名，用 this 区分，
本类的成员变量和父类的变量重名，用 super 区分

### Final

修饰的变量称为常量，值不能被修改
修饰的方法不能被重写，保证安全性和稳定性
修饰的类不能被继承，避免功能被覆盖。

要想让一个类不被其它类继承：

1. 用 final 修饰
2. 构造方法私有化

### Java 的继承与实现

继承可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。这种派生方式提现了传递性，在 Java 中，除了继承，还有一种提现传递性的方式叫做实现。

继承和实现两者的明确定义和区别如下：

继承（Inheritance）：如果多个类的某个部分的功能相同，那么可以抽象出一个类出来，把他们的相同部分都放到父类里，让他们都继承这个类。

实现（Implement）：如果多个类处理的目标是一样的，但是处理的方法方式不同，那么就定义一个接口，也就是一个标准，让他们的实现这个接口，各自实现自己具体的处理方法来处理那个目标

继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。所以，继承的根本原因是因为要复用，而实现的根本原因是需要定义一个标准。

在 Java 中，继承使用 extends 关键字实现，而实现通过 implements 关键字。

**Java 不支持多继承。**

## 多态(Polymorphism)

所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。

这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。

最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。

### 多态的必要条件

为了实现运行期的多态，或者说是动态绑定，需要满足三个条件：

- 有类继承或者接口实现
- 子类要重写父类的方法
- 父类的引用指向子类的对象

```java
public class Parent{

    public void call(){
        sout("im Parent");
    }
}

public class Son extends Parent{// 1.有类继承或者接口实现
    public void call(){// 2.子类要重写父类的方法
        sout("im Son");
    }
}

public class Daughter extends Parent{// 1.有类继承或者接口实现
    public void call(){// 2.子类要重写父类的方法
        sout("im Daughter");
    }
}

public class Test{

    public static void main(String[] args){
        Parent p = new Son(); //3.父类的引用指向子类的对象
        Parent p1 = new Daughter(); //3.父类的引用指向子类的对象
    }
}
```

这样，就实现了多态，同样是 Parent 类的实例，p.call 调用的是 Son 类的实现、p1.call 调用的是 Daughter 的实现。

### 向上转型和向下转型

多态的接地气的理解：父类作为形参，子类类型作为实参。

## 接口

1. 接口的语法规则

```java
public interface 接口名{
}
```

2. 接口的成员：

成员属性：public static final （公共的静态常量）类型

成员方法：public abstract （公共的抽象方法） 或静态方法

3. 接口的应用理解：

接口可以理解为定义的一组通用的组件，或者是对外提供服务的功能模块，具体可替换，可拆卸的特点。接口比抽象类更抽象，已经完全抽象得没边没影。

接口通常作为实体类的成员属性，和实体类是附属关系，而不是包含关系。

**抽象度：接口>抽象类>类>对象。**

## 泛型

Java 泛型是 jdk 1.5 中引入的一个新特性，其本质是参数化类型，也就是说所操作的数据类型被指定为一个参数（type parameter）这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。

- 引入案例

  需求：输出集合中所有的字符串

```java
ArrayList list = new ArrayList();
list.add("hello");
list.add("world");
list.add(666);
//需求：输出集合中所以的字符串
for (Object o:list){
    //会抛出类型转换异常
    System.out.println((String)o);
}
//异常分析：集合中数据类型不统一
```

- 案例改进

  在源头上对数据进行约束，除了字符串，其它类型数据不能放入集合

```java
//增加了泛型对类型进行约束
ArrayList <String> list = new ArrayList();
list.add("hello");
list.add("world");
list.add(666);//编译不通过
for (String s:list){//直接用String接收，无须强转
    //会抛出类型转换异常
    System.out.println(s);
}
```
